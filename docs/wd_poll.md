WD同步异步设计

-v0.1 wangzhou 2020/6/17

本文基于现有Linaro wd库的设计，做其中的异步和同步功能的设计。目前wd库中并没有
异步的设计，而且同步的实现中，由于存在cpu循环等待，存在cpu占用率搞的的问题。
本文梳理这些关系，并做相应设计。

0. 对齐概念
-----------

 在wd设计文档中，我们把全部wd相关的软件分为了，1. libwd库，2. libhisi_qm库，
 3. libhisi_comp库(可以是其他的算法库)。libwd提供基础通道的API接口，libhisi_qm
 在libwd的基础之上，提供海思qm的操作接口，算法库实现业务驱动，算法库调用
 libhisi_qm提供的队列管理接口。libwd库的API基本稳定，libhisi_qm库是对硬件的封装，
 也基本稳定，本文讨论算法库线程模型的设计。

 我们面对的硬件模型是：整个系统内分享硬件设备，e.g. /dev/hisi-zip[01]。多进程
 通过open硬件设备独占硬件队列，并行的使用硬件设备。设备上各个硬件队列没有做QoS，
 只要发包够快，单队列可以沾满设备全部性能。

 直接使用算法库的是用户。用户可能：1. 同步调用算法库接口，2. 异步调用算法库接口。
 其中，同步调用可能有大量线程同时调用算法库接口, e.g. ceph。因为硬件队列的个数
 有限，不同线程上的请求可能被发送到相同的硬件队列上。

 wd库基于SVA,在SVA的情况下，CPU只需要组包发给硬件，CPU的消耗很小，瓶颈在加速器上。
 由于目前的加速器硬件没有做QoS, 负载会直接加到整个加速器上。曾大队列数没有作用。

1. 同步接口
-----------

 基于这样的模型，对于同步的情况，当硬件处理时间很短的时候，发包后直接poll即可。
 当硬件处理比较长的时候，需要让出CPU，避免消耗过多CPU做poll。这里硬件处理时间长
 可能是 1. 包长比较大，2. 硬件资源被他人占用。因为我们无法准确估计，处理时间长
 的时候，需要让出CPU的时间，我们引入专门的IO处理线程去处理IO，业务线程发包完毕
 后让出CPU，并激活IO线程去处理IO，IO处理完后通知业务线程。

2. 异步接口
-----------

 用户可能会下发异步请求给wd库，用户下发一个请求，以及这个请求完成后需要调用的
 回调函数。算法层接收用户发送的请求后，发送给硬件队列。算法层需要起线程poll完成
 的任务，当poll到完成的任务时调用用户下发的回调函数。
